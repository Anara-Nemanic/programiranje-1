\documentclass[arhiv]{../izpit}
\usepackage{fouriernc}
\usepackage{xcolor}
\usepackage{fancyvrb}


\begin{document}
	
\izpit{Programiranje I: 2. izpit}{7.\ februar 2022}{
  Čas reševanja je 120 minut.
  Veliko uspeha!
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\naloga

\podnaloga
Napišite predikat \verb|je_idempotent : (int * int) * (int * int) -> bool|,
   ki za dano dvodimenzionalno matriko pove, ali je idempotentna.
   Matrika $P$ je idempotentna, kadar velja $P^2 = P$.

  %  let je_idempotent ((a, b), (c, d)) =
  %   a*a + b*c = a && a*b + b*d = b && a*c + c*d = c && b*c + d*d = d
  
Primera dveh idempotentnih matrik:
\begin{verbatim}
  # let identiteta = ((1, 0), (0, 1));;
  # let test1 = ((3, -6), (1, -2));;
  # je_idempotent identiteta;;
  - : bool = true
  # je_idempotent test1;;
  - : bool = true
\end{verbatim}

Primer matrike, ki ni idempotentna:
\begin{verbatim}
  let test2 = ((1, -6), (1, -2));;
  # je_idempotent test2;;
  - : bool = true
 \end{verbatim}
  
\podnaloga
Napišite funkcijo, ki izračuna produkt neničelnih elementov v seznamu.
Produkt praznega seznama naj bo enak $1$. Funkcija naj bo repno rekurzivna.
  
  % let produkt lst =
  %   let rec aux acc = function
  %     | [] -> acc
  %     | 0 :: t -> aux acc t
  %     | x :: t -> aux (acc * x) t
  %   in
  %   aux 1 lst

\podnaloga
Napišite funkcijo \verb|stalin|, ki iz danega seznama odstrani vse elemente, 
ki niso v strogo naraščajočem vrstnem redu, po požrešni metodi.

Primer:
\begin{verbatim}
  # stalin [6; 3; 10; 5; 16];;
  - : int list = [6; 10; 16]
\end{verbatim}

% let stalin lst = 
%   let rec aux acc max = function
%     | [] -> acc
%     | x :: xs -> 
%       if x > max then aux (x :: acc) x xs
%       else aux acc max xs
%   in
%   match lst with
%     | [] -> []
%     | x :: xs -> List.rev (aux [x] x xs)

  \podnaloga
  Napišite funkcijo \verb|splosni_collatz| ki za dani funkciji \verb|f| in \verb|g|, \verb|pogoj : int -> bool|, 
  začetno število \verb|z|, končno število \verb|k| in maksimalno število ponovitev \verb|n|, 
  računa člene splošne verzije Collatzovega zaporedja, dokler ne pride do števila \verb|k| 
  ali do maksimalnega števila ponovitev.
  Člen zaporedja je določen s prejšnjim členom tako, da se uporabi funkcija \verb|f| na prejšnjem členu,
  če zanj velja pogoj, sicer pa se uporabi funkcija \verb|g|.  

  % let splosni_collatz f g pogoj z k n =
  %   let rec aux x n = 
  %     (* print_int x; print_string " "; *)
  %     x :: (if n <= 0 || x = k then []
  %     else
  %       if pogoj x then aux (f x) (n-1)
  %       else aux (g x) (n-1)
  %     )
  %     in aux z n
  
  Primer: originalno Collatzovo zaporedje
\begin{verbatim}
  # let pogoj x = (x mod 2) = 0;;
  # let f x = x / 2;;
  # let g x = 3 * x + 1;;
  # splosni_collatz f g pogoj 12 1 1000;;
  - : int list = [12; 6; 3; 10; 5; 16; 8; 4; 2; 1]
\end{verbatim}

  V primeru začnemo s številom $12$, ki je deljivo z $2$ (pogoj), zato uporabimo funkcijo \verb|f|.
  Dobimo število $6$, ki je spet deljivo z $2$, zato spet uporabimo \verb|f|.
  Naslednje število je $3$, ki pa ni deljivo z $2$, zato uporabimo funkcijo \verb|g|, in dobimo število $10$.
  Postopek ponavljamo, dokler ne pridemo do končnega števila $1$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\naloga

Računanje aritmetičnih izrazov lahko predstavimo s skladom, kjer aritmetični izraz predstavimo kot 
zaporedje števil in operatorjev na skladu (seznamu). 
Izraz \verb|(3 + 4) / 5| predstavimo kot: \verb|"3 4 + 5 /"|. 
Aritmetične izraze v taki obliki evalviramo od leve proti desni tako, da najprej s sklada vzamemo 
oba argumenta in operator, operator apliciramo na operanda in na sklad vrnemo rezultat. 
To počnemo toliko časa, dokler ni na skladu zgolj en element, ki je končni rezultat. 
V kolikor med izvajanjem na vrhu sklada ni pravilnih oblik elementov, ali na koncu ostane nepravilno 
število elementov je tekom izvajanja prišlo do napake.  

\begin{verbatim}
  type 'a operator = 'a -> 'a -> 'a

  type 'a atom = Value of 'a | Operator of 'a operator
  
  type 'a term = 'a atom list
  
  type 'a result = Finished of 'a | Term of 'a term | Error
  
  let plus = Operator ( + )
  
  let krat = Operator ( * )
  
  let deljeno = Operator ( / )
  
  let primer : int term = [ Value 3; Value 4; plus; Value 5; deljeno ]    
\end{verbatim}

\podnaloga Definirajte izraza, ki ju predstavljata sledeča niza: \verb|"1 2 + 4 - 5 *"|, \verb|"5.3 4.6 /. 1.7 *."|. 
   Definirajte tudi poljuben izraz, ki predstavlja neveljaven izraz (kjer bi med izvajanjem prišlo do napake)

% let a = [ Value 1; Value 2; plus; Value 4; Operator ( - ); Value 5; krat ]
% let b = [ Value 5.3; Value 4.6; Operator ( /. ); Value 1.7; Operator ( *. ) ]
% let prevec_vrednosti = [ Value 3; Value 4 ]

\podnaloga
Definiraje funkcijo \verb|korak 'a term -> 'a result|, ki sprejme izraz (sklad) in poskuša narediti en korak evalvacije.
Če podan izraz predstavlja končni rezultat naj vrne obliko \verb|Finished|, 
če je mogoče narediti en korak naj naredi en korak in vrne stanje po opravljenem koraku v obliki \verb|Term|, 
v nasprotnem primeru pa naj vrne obliko \verb|Error|.

\begin{verbatim}
  # korak primer;;
  - : int result = Term [Value 7; Value 5; Operator <fun>]
  # korak [Value 7; Value 5; deljeno];;
  - : int result = Term [Value 1]
  # korak [Value 1];;
  - : int result = Finished 1
\end{verbatim}

% let korak = function
%   | [ Value x ] -> Finished x
%   | Value x :: Value y :: Operator o :: xs -> Term (Value (o x y) :: xs)
%   | _ -> Error

\podnaloga
Definirajte funkcijo \verb|izvedi : 'a term -> 'a option|, ki sprejme izraz in ga evalvira. 
Če kjerkoli med izvajanje pride do napake naj funkcija vrne \verb|None|.

% let rec izvedi term =
%   match korak term with
%   | Finished r -> Some r
%   | Term t -> izvedi t
%   | Error -> None

\podnaloga
Definirajte predikat \verb|valid : 'a term -> bool|, ki sprejme izraz in preveri, 
ali je podan izraz veljaven (ali bi izvedba izraza v celoti pripeljala do rezultata, 
ali bi vmes prišlo do napake). 
Za vse točke naj bo funkcija repno rekurzivna in ne gre v celoti izvesti izraza (ne aplicira funkcij).

% let valid term =
%   let rec aux = function
%     | [] -> true
%     | Value _ :: Operator _ :: xs -> aux xs
%     | _ -> false
%   in
%   match term with Value _ :: xs -> aux xs | _ -> false

\podnaloga
Očitno lahko iz seznama operatorjev in vrednosti pripravimo izraz. 
Vaša naloga je pripraviti funkcijo \verb|combine : 'a list -> 'a operator list -> 'a term option|, 
ki sprejme seznam vrednosti in seznam operatorjev ter vrne končen izraz, če je to mogoče, ali \verb|None|.

% let combine values operators : 'a term option =
%   let rec aux values operators =
%     match (values, operators) with
%     | [], [] -> Some []
%     | v :: vs, o :: os ->
%         Option.map (fun l -> Value v :: Operator o :: l) (aux vs os)
%     | _ -> None
%   in
%   match values with
%   | [] -> None
%   | v :: values -> Option.map (fun l -> Value v :: l) (aux values operators)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\naloga

France 9.~februarja zjutraj prazni dolgo mizo, za katero je prejšnji večer praznovalo $N$ gostov (vsi v eni sami vrsti). Vsak izmed njih je za sabo pustil nekaj (nenegativnih) enot hrane in pijače. Ker je Francetu med pospravljanjem dolgčas, se je odločil, da se bo namesto pospravljanja raje igral igrico po naslednjih pravilih.

\begin{enumerate}
  \item Pospravljanje začne skrajno levo s praznim vrčem.
  France hoče priti do desnega konca mize.
  \item Na vsakem koraku se odloči, za koliko mest se bo premaknil v desno. 
  \item\label{i:obisk} Ko pride na posamezno mesto, si pretoči pijačo v vrč,
  nato pa se vrne na levo za toliko mest, kolikor je na trenutnem mestu gost pustil enot hrane.
  \item Ker je od prejšnjega dne še hudo utrujen, ob vsakem premiku (tako naprej kot nazaj) polije toliko enot pijače kot je premik dolg.
  \item Ob vrnitvi na levo po pravilu~\ref{i:obisk} si ne natoči dodatne pijače, niti se ne vrača še bolj na levo.
  Nikoli se ne vrne preko levega roba mize.
  \item Pijače v vrču ne sme zmanjkati, pri čemer je treba upoštevati spremembe med obiski.
  \item Celotna zbrana družba Franceta budno opazuje in skrbi, da se po obisku količina pijače
  na obiskanem mestu vrne v prvotno stanje.
\end{enumerate}

France lahko s tremi enotami v kozarcu obišče mesto, ki je oddaljeno $3$ mesta, 
štiri mesta proti desni pa bi bilo že preveč. 
S štirimi enotami lahko obišče mesto, ki ima dve enoti hrane in je oddaljeno tri mesta, ampak le, če ima to mesto vsaj eno enoto pijače (drugače bi ob premiku nazaj ostal s praznim kozarcem).

Napišite funkcijo \verb|pospravi|, ki sprejme seznam parov celih števil. 
Prva komponenta para pove količino hrane, druga pa količino pijače na posameznem mestu. Funkcija naj vrne celo število: najmanjše število mest, ki jih mora France obiskati, 
da se prebije do konca mize. 
Vaša rešitev lahko predpostavi, da bo to vedno mogoče v končno mnogo korakih.

Na spodnji mizi si na indeksu \verb|0| natoči dve enoti pijače.
Naprej se po poti z najmanjšim številom obiskanih mest najprej premakne na indeks \verb|2|.
Na to mesto pride s praznim vrčem, v katerega natoči pet enot in se vrne na začetek s tremi enotami pijače. 
V drugo se spet premakne na indeks \verb|2|, ter se vrne na začetek s štirimi enotami pijače.
V tretje se premakne na indeks \verb|1|, odkoder se vrne na začetek s petimi enotami pijače.
Zdaj ima dovolj zaloge, da lahko s četrtim premikom doseže konec mize.
Alternativno bi lahko v tretjem premiku šel na indeks \verb|2| in še vedno v enakem številu premikov dosegel konec mize.


\verb|[(1, 2), (1, 3), (3, 5), (5, 0), (5, 1)]|

\end{document}
