\documentclass[arhiv]{../izpit}
\usepackage{fouriernc}
\usepackage{xcolor}
\usepackage{fancyvrb}


\begin{document}
	
\izpit{Programiranje I: 2. izpit}{7.\ februar 2022}{
  Čas reševanja je 120 minut.
  Veliko uspeha!
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\naloga

\podnaloga
Napišite predikat \verb|je_idempotent : (int * int) * (int * int) -> bool|,
   ki za dano dvodimenzionalno matriko pove, ali je idempotentna.
   Matrika $P$ je idempotentna, kadar velja $P^2 = P$.

  %  let je_idempotent ((a, b), (c, d)) =
  %   a*a + b*c = a && a*b + b*d = b && a*c + c*d = c && b*c + d*d = d
  
Primera dveh idempotentnih matrik:
\begin{verbatim}
  # let identiteta = ((1, 0), (0, 1));;
  # let test1 = ((3, -6), (1, -2));;
  # je_idempotent identiteta;;
  - : bool = true
  # je_idempotent test1;;
  - : bool = true
\end{verbatim}

Primer matrike, ki ni idempotentna:
\begin{verbatim}
  let test2 = ((1, -6), (1, -2));;
  # je_idempotent test2;;
  - : bool = true
 \end{verbatim}
  
\podnaloga
Napišite funkcijo, ki izračuna produkt neničelnih elementov v seznamu.
Produkt praznega seznama naj bo enak $1$. Funkcija naj bo repno rekurzivna.
  
  % let produkt lst =
  %   let rec aux acc = function
  %     | [] -> acc
  %     | 0 :: t -> aux acc t
  %     | x :: t -> aux (acc * x) t
  %   in
  %   aux 1 lst

\podnaloga
Napišite funkcijo \verb|stalin|, ki iz danega seznama odstrani vse elemente, 
ki niso v strogo naraščajočem vrstnem redu, po požrešni metodi.

Primer:
\begin{verbatim}
  # stalin [6; 3; 10; 5; 16];;
  - : int list = [6; 10; 16]
\end{verbatim}

% let stalin lst = 
%   let rec aux acc max = function
%     | [] -> acc
%     | x :: xs -> 
%       if x > max then aux (x :: acc) x xs
%       else aux acc max xs
%   in
%   match lst with
%     | [] -> []
%     | x :: xs -> List.rev (aux [x] x xs)

  \podnaloga
  Napišite funkcijo \verb|splosni_collatz| ki za dani funkciji \verb|f| in \verb|g|, \verb|pogoj : int -> bool|, 
  začetno število \verb|z|, končno število \verb|k| in maksimalno število ponovitev \verb|n|, 
  računa člene splošne verzije Collatzovega zaporedja, dokler ne pride do števila \verb|k| 
  ali do maksimalnega števila ponovitev.
  Člen zaporedja je določen s prejšnjim členom tako, da se uporabi funkcija \verb|f| na prejšnjem členu,
  če zanj velja pogoj, sicer pa se uporabi funkcija \verb|g|.  

  % let splosni_collatz f g pogoj z k n =
  %   let rec aux x n = 
  %     (* print_int x; print_string " "; *)
  %     x :: (if n <= 0 || x = k then []
  %     else
  %       if pogoj x then aux (f x) (n-1)
  %       else aux (g x) (n-1)
  %     )
  %     in aux z n
  
  Primer: originalno Collatzovo zaporedje
\begin{verbatim}
  # let pogoj x = (x mod 2) = 0;;
  # let f x = x / 2;;
  # let g x = 3 * x + 1;;
  # splosni_collatz f g pogoj 12 1 1000;;
  - : int list = [12; 6; 3; 10; 5; 16; 8; 4; 2; 1]
\end{verbatim}

  V primeru začnemo s številom $12$, ki je deljivo z $2$ (pogoj), zato uporabimo funkcijo \verb|f|.
  Dobimo število $6$, ki je spet deljivo z $2$, zato spet uporabimo \verb|f|.
  Naslednje število je $3$, ki pa ni deljivo z $2$, zato uporabimo funkcijo \verb|g|, in dobimo število $10$.
  Postopek ponavljamo, dokler ne pridemo do končnega števila $1$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\naloga

Računanje aritmetičnih izrazov lahko predstavimo s skladom, kjer aritmetični izraz predstavimo kot 
zaporedje števil in operatorjev na skladu (seznamu). 
Izraz \verb|(3 + 4) / 5| predstavimo kot: \verb|"3 4 + 5 /"|. 
Aritmetične izraze v taki obliki evalviramo od leve proti desni tako, da najprej s sklada vzamemo 
oba argumenta in operator, operator apliciramo na operanda in na sklad vrnemo rezultat. 
To počnemo toliko časa, dokler ni na skladu zgolj en element, ki je končni rezultat. 
V kolikor med izvajanjem na vrhu sklada ni pravilnih oblik elementov, ali na koncu ostane nepravilno 
število elementov je tekom izvajanja prišlo do napake.  

\begin{verbatim}
  type 'a operator = 'a -> 'a -> 'a

  type 'a atom = Value of 'a | Operator of 'a operator
  
  type 'a term = 'a atom list
  
  type 'a result = Finished of 'a | Term of 'a term | Error
  
  let plus = Operator ( + )
  
  let krat = Operator ( * )
  
  let deljeno = Operator ( / )
  
  let primer : int term = [ Value 3; Value 4; plus; Value 5; deljeno ]    
\end{verbatim}

\podnaloga Definirajte izraza, ki ju predstavljata sledeča niza: \verb|"1 2 + 4 - 5 *"|, \verb|"5.3 4.6 /. 1.7 *."|. 
   Definirajte tudi poljuben izraz, ki predstavlja neveljaven izraz (kjer bi med izvajanjem prišlo do napake)

% let a = [ Value 1; Value 2; plus; Value 4; Operator ( - ); Value 5; krat ]
% let b = [ Value 5.3; Value 4.6; Operator ( /. ); Value 1.7; Operator ( *. ) ]
% let prevec_vrednosti = [ Value 3; Value 4 ]

\podnaloga
Definiraje funkcijo \verb|korak 'a term -> 'a result|, ki sprejme izraz (sklad) in poskuša narediti en korak evalvacije.
Če podan izraz predstavlja končni rezultat naj vrne obliko \verb|Finished|, 
če je mogoče narediti en korak naj naredi en korak in vrne stanje po opravljenem koraku v obliki \verb|Term|, 
v nasprotnem primeru pa naj vrne obliko \verb|Error|.

\begin{verbatim}
  # korak primer;;
  - : int result = Term [Value 7; Value 5; Operator <fun>]
  # korak [Value 7; Value 5; deljeno];;
  - : int result = Term [Value 1]
  # korak [Value 1];;
  - : int result = Finished 1
\end{verbatim}

% let korak = function
%   | [ Value x ] -> Finished x
%   | Value x :: Value y :: Operator o :: xs -> Term (Value (o x y) :: xs)
%   | _ -> Error

\podnaloga
Definirajte funkcijo \verb|izvedi : 'a term -> 'a option|, ki sprejme izraz in ga evalvira. 
Če kjerkoli med izvajanje pride do napake naj funkcija vrne \verb|None|.

% let rec izvedi term =
%   match korak term with
%   | Finished r -> Some r
%   | Term t -> izvedi t
%   | Error -> None

\podnaloga
Definirajte predikat \verb|valid : 'a term -> bool|, ki sprejme izraz in preveri, 
ali je podan izraz veljaven (ali bi izvedba izraza v celoti pripeljala do rezultata, 
ali bi vmes prišlo do napake). 
Za vse točke naj bo funkcija repno rekurzivna in ne gre v celoti izvesti izraza (ne aplicira funkcij).

% let valid term =
%   let rec aux = function
%     | [] -> true
%     | Value _ :: Operator _ :: xs -> aux xs
%     | _ -> false
%   in
%   match term with Value _ :: xs -> aux xs | _ -> false

\podnaloga
Očitno lahko iz seznama operatorjev in vrednosti pripravimo izraz. 
Vaša naloga je pripraviti funkcijo \verb|combine : 'a list -> 'a operator list -> 'a term option|, 
ki sprejme seznam vrednosti in seznam operatorjev ter vrne končen izraz, če je to mogoče, ali \verb|None|.

% let combine values operators : 'a term option =
%   let rec aux values operators =
%     match (values, operators) with
%     | [], [] -> Some []
%     | v :: vs, o :: os ->
%         Option.map (fun l -> Value v :: Operator o :: l) (aux vs os)
%     | _ -> None
%   in
%   match values with
%   | [] -> None
%   | v :: values -> Option.map (fun l -> Value v :: l) (aux values operators)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\naloga

France 9.~februarja zjutraj prazni dolgo mizo, za katero je prejšnji večer praznovalo $N$ gostov (vsi v eni sami vrsti). Vsak izmed njih je za sabo pustil nekaj (nenegativnih) enot hrane in pijače. Ker je Francetu med pospravljanjem dolgčas, se je odločil, da se bo namesto pospravljanja raje igral igrico.

Pospravljanje začne skrajno levo s praznim vrčem in se premika v desno. Ko pride na posamezno mesto, si vso pijačo, ki je ostala tam, pretoči v svoj kozarec in se vrne nazaj (v levo) za toliko mest, kot je gost pustil hrane. Ob vrnitvi na desno si ne natoči dodatne pijače, niti ne ponovi vračanja. Če bi se slučajno moral premaknit preko levega roba mize, potem se bo ob levem robu mize tudi ustavil. Ker je od prejšnjega dne še hudo utrujen, ob vsakem premiku (tako naprej kot nazaj) polije toliko enot pijače kot je le-ta dolg. Pri tem mora paziti, da ima v kozarcu vedno vsaj nekaj pijače. Dovoljeno je na primer, da s 3 enotami v kozarcu naredi premik dolg 3 enote, 4 pa je že preveč. Pri tem mora upoštevati tudi možne premike zaradi hrane in dodajanje pijače na posameznem mestu. S štirimi enotami se lahko premakne na mesto ki ima dve enoti hrane in je oddaljeno tri mesta, le, če ima to mest vsaj eno enoto pijače (drugače bi ob premiku nazaj ostal s praznim kozarcem). Zanima ga najmanj koliko mest bo obiskal, preden mu bo uspelo priti čez desni konec mize (z nenegativno količino pijače)? Pri tem ga budno opazuje celotna zbrana družba in skrbi, da se stanje na mizi ne spremeni (če bi dvakrat obiskal isto mesto, se je pijača tam vrnila na enako stanje, kot je bila na začetku).

Napišite funkcijo \verb|pospravi|, ki sprejme seznam parov celih števil. Prva komponenta para pove količino hrane, druga pa pijače na posameznem mestu in vrne celo število, najmanjše število premikov, ki jih mora France opraviti, da se prebije do konca mize. Vaša rešitev lahko predpostavi, da bo to vedno mogoče v končno mnogo korakih.

Na spodnji mizi je najbolje, da najboljša pot, ki začne na indeksu 0 (si natoči dve enoti pijače), od koder se premakne na indeks 2 (kjer ima prazen kozarec) in se vrne nazaj na začetek, kjer ima sedaj 3 enote pijače. V drugo se spet premakne na indeks 2, in vrne nazaj na začetek s 4 enotami pijače. V tretje pa se premakne na indeks 1, in se vrne nazaj na začetek s 5 enotami pijače, s čimer ima dovolj zaloge da lahko s četrtim premikom doseže konec mize. (Alternativno bi lahko v tretjem premiku šel na indeks 2 in še vedno v enakem številu premikov dosegel konec mize).


\verb|[(1, 2), (1, 3), (3, 5), (5, 0), (5, 1)]|

\end{document}
